;; -------------------------------------------------------------------
;;    Joseph Vendryes
;;    May 2021
;;    Mastermind v2 Model
;; -------------------------------------------------------------------

#lang racket

(provide (prefix-out mastermind- (combine-out play
                                              first-play
                                              game-over?
                                              impossible?
                                              (struct-out board))))


;; -------------------------------------------------------------------
;; Discussion and Terminology

;; In this discussion, a basic familiarity with the game of Mastermind
;;    is assumed.
;; The algorithm implemented here performs the role of the mind,
;;    which entails generating guesses based on previous attempts and
;;    their associated marks. For ease of computation, the colours of
;;    which the code is comprised are represented by natural numbers.
;;    Marks are supplied in aggregate per attempt, where Red marks
;;    represent the right colour in the Right spot, and White marks
;;    represent the right colour in the Wrong spot. Past attempts are
;;    stored in a list, ordered with the most recent attempt at the
;;    front of the list. Marks are stored similarly, with separate
;;    lists for red and white marks.
;; Past attempts are stored in a different format from how they would
;;    typically be displayed. Considering the typical display format
;;    as an indexed list, this storage format specifies a list of
;;    indices for each colour. These lists of indices are placed into
;;    a larger list, which represents a single attempt. The last list
;;    in an attempt contains the indices at which that attempt assigns
;;    the colour 0, the second last contains the indices for 1, and so
;;    increasing to the front of the list. Not every attempt uses
;;    every colour, but the number of colours used can be found by
;;    counting the number of lists in a given attempt.
;; A new guess is generated by tentatively assigning the aggregate
;;    marks for each past attempt to specific items in that attempt.
;;    Once a consistent arrangement is found, it immediately implies
;;    a certain number of items in the new guess. The remaining spots
;;    in the new guess are filled with the smallest colour (number)
;;    that does not create a discrepancy with the specifically
;;    assigned marks.
;; When assigning marks specifically, the arrangement cycles through
;;    a pattern until consistency is reached. In this pattern,
;;    priority is given to the smaller colours to remain the same
;;    while all possible combinations of the larger colours are tried.
;;    The arrangement itself is passed on from attempt to attempt
;;    under the moniker of "guess," and it closely resembles an
;;    attempt. The real difference between the guess and an attempt is
;;    that the guess retains "void symbols" from previous assignments.
;;    Void symbols are place markers for the indices assigned as not
;;    having merited either a red or white mark. They take the form of
;;    the value 'N. When a consistent arrangement is found, the void
;;    symbols are filtered out of the guess, a new list of all missing
;;    indices is added to the front of the guess, and this is added
;;    onto the front of the list of past attempts. It is also printed
;;    in readable form with drop-down selections for the user to
;;    specify the red and white aggregate marks for that attempt.
;; Since the largest colours are cycled first, and since they are
;;    always the most recent and so appear at the front of the guess,
;;    enough calculation is performed on the first list in the guess
;;    to warrant its own name: the "mouth" of the guess. Similarly,
;;    each attempt has a mouth, against which the guess mouth can be
;;    compared to distinguish red and white assignments. This
;;    comparison is crucial to the cycling process, which proceeds as
;;    follows:
;;       1. Stretch whites
;;             A white in the guess mouth (a number different from
;;             its correspondent in the current attempt mouth)
;;             is "stretchable" if it can be "stretched" once without
;;             becoming a red (the same as its correspondent). To
;;             stretch a white, add 1 to it. If this results in an
;;             index beyond the code length, replace it with 0.
;;          In this step, stretch the last stretchable white in the
;;             guess mouth, and do the following to all later whites:
;;                1. Set equal to correspondent,
;;                2. Stretch once. The white is now called "fresh."
;;             Only if there is no stretchable white, move to step 2.
;;       2. Move whites
;;             To "move" a white or red to a void symbol, simply set
;;             the white or red as a void symbol and the void symbol
;;             as a fresh white or a red. A white or red is "movable"
;;             if a void symbol occurs after it in the guess mouth.
;;          In this step, move the last movable white to the next
;;             void symbol. Move each later white as far to the front
;;             as possible without changing the order of the whites.
;;             Only if there is no movable white, move to step 3.
;;       3. Move reds
;;          In this step, first count the number of whites and set
;;             them all as void symbols. Then move the last movable
;;             red to the next void symbol, and move each later red
;;             as far to the front as possible without changing the
;;             order of the reds. Finally, recalling the number of
;;             whites, set the first that many void symbols as fresh
;;             whites.
;;             Only if there is no movable red, move to step 4.
;;       4. Step back one level
;;          In this step, the guess mouth cannot be cycled. Go to the
;;             previous attempt by taking the rest of the guess and
;;             the rest of the history of attempts, and cycle that
;;             until it is consistent. Then return to this attempt and
;;             cycle until it is consistent.
;; The first guess is always comprised only of the smallest colour, 0,
;;    since there are no previous marks. Each successive guess adds
;;    another colour, until the sum of red and white marks is equal
;;    to the length of the code. At that point, the colours in the
;;    master code are known, and they are simply rearranged until the
;;    correct arrangement is discovered.


;; -------------------------------------------------------------------
;; Data Definitions

;; These data definitions utilize the parameters code-length and
;;    pool-size, which specify the length of the code and the number
;;    of colours, respectively. Also void-symbol, which is a Sym.

;; A Colour is a Nat < pool-size

;; An Index is a Nat < code-length

;; An Attempt is a non-empty (listof (listof Index))
;;    containing every possible Index exactly once.

;; A History is a non-empty (listof Attempt)
;; Requires:
;;    The last Attempt has length 1
;;    Each Attempt has length 1 more than the next

;; An AttemptMouth is a (listof Index)

;; A GuessIndex is (Anyof Index void-symbol)

;; A Guess is one of
;; * a non-empty (listof (listof GuessIndex))
;; * 'impossible

;; A GuessMouth is a (listof GuessIndex)

(define-struct board
  (guess history reds whites code-length pool-size))
;; A Board is a
;;    (make-board Guess History (listof Index) (listof Index) Nat Nat)
;; Requires: history, reds, and whites are all the same length


;; -------------------------------------------------------------------
;; Constants

(define void-symbol 'N)


;; -------------------------------------------------------------------
;; Main Function

(define (first-play code-length pool-size)
  (define guess   (list (build-list code-length (lambda (n) n))))
  (define history empty)
  (define reds    empty)
  (define whites  empty)
  
  (make-board guess history reds whites code-length pool-size))

(define (play board new-red new-white)
  (define guess       (board-guess       board))
  (define history     (board-history     board))
  (define reds        (board-reds        board))
  (define whites      (board-whites      board))
  (define code-length (board-code-length board))
  (define pool-size   (board-pool-size   board))

  (define new-history (cons (simplify guess) history))
  (define new-reds    (cons new-red reds))
  (define new-whites  (cons new-white whites))
  (define new-guess   (complete (generate guess new-history
                                          new-reds new-whites
                                          code-length)
                                code-length))

  (make-board new-guess new-history new-reds new-whites
              code-length pool-size))

(define (game-over? board)
  (= (first (board-reds board))
     (board-code-length board)))

(define (impossible? board)
  (or (and (symbol? (board-guess board))
           (symbol=? (board-guess board) 'impossible))
      (colours-exhausted? board)))

(define (colours-exhausted? board)
  (and (> (length (board-guess board))
          (board-pool-size board))
       (not (empty? (first (board-guess board))))))


;; -------------------------------------------------------------------
;; Helper Functions

;; ---------------
;; (generate guess history r w code-length) produces a consistent
;;    arrangement distributing r and w through history, cycling from a
;;    numerical correction of guess, for codes of length code-length.
;; Examples:
;(check-expect (generate '((0)) '(((0))) '(0) '(0) 1) '((N)))
;(check-expect (generate '((0) (N)) '(((0) ()) ((0))) '(0 0) '(0 0) 1)
;              '((N) (N)))
;(check-expect (generate '((0 1 2)) '(((0 1 2))) '(2) '(0) 3)
;              '((0 1 N)))
;(check-expect
; (generate '((1 2) (0 N N)) '(((1 2) (0)) ((0 1 2))) '(1 1) '(1 0) 3)
; '((N 2) (N 1 N)))
;(check-expect
; (generate '((1 2) (0 N N)) '(((1 2) (0)) ((0 1 2))) '(0 1) '(1 0) 3)
; '((N N) (N 1 N)))

;; generate: Guess History (listof Nat) (listof Nat) Nat -> Guess
;; Requires:
;;    guess is the same length as the first of history
;;      or guess is 'impossible
;;    r and w are the same length as history
(define (generate guess history r w code-length)
  (cond [(and (symbol? guess) (symbol=? guess 'impossible))
         'impossible]
        [else
         (define current (first history))

         (define count-r (count true (rest guess) (rest current)))
         (define count-w (count false (rest guess) (rest current)))

         (define excess-r (- (first r) count-r))
         (define excess-w (- (first w) count-w))

         (if (and (>= excess-r 0)
                  (>= excess-w 0))
             (rectify (fill excess-r
                            excess-w
                            (cons (first current) (rest guess))
                            code-length)
                      history r w code-length)
             (generate (complete (rectify (cycle (rest guess)
                                                 (rest history)
                                                 (rest r)
                                                 (rest w)
                                                 code-length)
                                          (rest history)
                                          (rest r)
                                          (rest w)
                                          code-length)
                                 code-length)
                       history r w code-length))]))


;; ---------------
;; (complete guess code-length) adds onto the front of guess
;;    a list of all indices less than code-length that are not
;;    already in guess.
;; Examples:
;(check-expect (complete '((0 N N N)) 4) '((1 2 3) (0 N N N)))
;(check-expect (complete '((N 2 N) (N 1 N N)) 4)
;              '((0 3) (N 2 N) (N 1 N N)))

;; complete: Guess Nat -> Guess
(define (complete rguess code-length)
  (if (and (symbol? rguess) (symbol=? rguess 'impossible))
      'impossible
      (cons (filter (lambda (n)
                      (not (member? n (foldr append '() rguess))))
                    (build-list code-length (lambda (n) n)))
            rguess)))


;; ---------------
;; (member? item lst) produces true if lst contains item, and
;;    false otherwise.

;; member? Any (listof Any) -> Bool
(define (member? item lst)
  (ormap (lambda (lst-item) (equal? item lst-item)) lst))


;; ---------------
;; (rectify guess history r w code-length) produces guess if it is
;;    consistent, or else cycles it with respect to history, r, and w,
;;    until it is consistent. For codes of length code-length.
;; Examples:
;(check-expect (rectify '((N)) '(((0))) '(0) '(0) 1) '((N)))
;(check-expect (rectify '((N) (N)) '(((0) ()) ((0))) '(0 0) '(0 0) 1)
;              '((N) (N)))
;(check-expect (rectify '((0 1 N)) '(((0 1 2))) '(2) '(0) 3)
;              '((0 1 N)))
;(check-expect
; (rectify '((2 N) (0 N N)) '(((1 2) (0)) ((0 1 2))) '(1 1) '(1 0) 3)
; '((N 2) (N 1 N)))

;; rectify: Guess History (listof Nat) (listof Nat) Nat -> Guess
;; Requires:
;;    guess is the same length as the first of history
;;      or guess is 'impossible
;;    r and w are the same length as history
(define (rectify guess history r w code-length)
  (cond [(and (symbol? guess) (symbol=? guess 'impossible))
         'impossible]
        [(rectified? guess (first history) (first r) (first w))
         guess]
        [else (rectify (cycle guess history r w code-length)
                       history r w code-length)]))


;; ---------------
;; (rectified? guess current count-r count-w) produces true iff guess
;;    is a consistent correction of current with count-r red marks and
;;    count-w white marks.
;; Examples:
;(check-expect (rectified? '((N 2 N) (N 1 N N)) '((1 2 3) (0)) 1 1)
;              true)
;(check-expect (rectified? '((2 N N) (0 N N N)) '((1 2 3) (0)) 1 1)
;              false)
;(check-expect (rectified? '((0 N N) (0 N N N)) '((1 2 3) (0)) 1 1)
;              false)

;; rectified?: Guess Attempt Nat Nat -> Bool
;; Requires: guess and current are the same non-zero length
(define (rectified? guess current count-r count-w)
  (and (let no-double-numbers ([lst (foldr append '() guess)])
         (or (empty? lst)
             (and (no-double-numbers (rest lst))
                  (not (and (number? (first lst))
                            (member? (first lst) (rest lst)))))))
       (= count-r (count true guess current))
       (= count-w (count false guess current))))


;; ---------------
;; (cycle guess history r w code-length) cycles guess with respect to
;;    history, r, and w. For codes of length code-length.
;; Examples:
;(check-expect
; (cycle '((2 3 5 6 N) (1 N N N N N) (0 N N N N N N))
;        '(((2 3 4 5 6) (1) (0))
;          ((1 2 3 4 5 6) (0))
;          ((0 1 2 3 4 5 6)))
;        '(2 1 1) '(2 0 0) 7)
; '((2 3 5 0 N) (1 N N N N N) (0 N N N N N N)))
;(check-expect
; (cycle '((2 3 5 4 N) (1 N N N N N) (0 N N N N N N))
;        '(((2 3 4 5 6) (1) (0))
;          ((1 2 3 4 5 6) (0))
;          ((0 1 2 3 4 5 6)))
;        '(2 1 1) '(2 0 0) 7)
; '((2 3 6 6 N) (1 N N N N N) (0 N N N N N N)))
;(check-expect
; (cycle '((2 3 3 4 N) (1 N N N N N) (0 N N N N N N))
;        '(((2 3 4 5 6) (1) (0))
;          ((1 2 3 4 5 6) (0))
;          ((0 1 2 3 4 5 6)))
;        '(2 1 1) '(2 0 0) 7)
; '((2 3 5 N 0) (1 N N N N N) (0 N N N N N N)))
;(check-expect
; (cycle '((2 3 N 4 5) (1 N N N N N) (0 N N N N N N))
;        '(((2 3 4 5 6) (1) (0))
;          ((1 2 3 4 5 6) (0))
;          ((0 1 2 3 4 5 6)))
;        '(2 1 1) '(2 0 0) 7)
; '((2 4 4 6 N) (1 N N N N N) (0 N N N N N N)))
;(check-expect
; (cycle '((N 2 3 5 6) (1 N N N N N) (0 N N N N N N))
;        '(((2 3 4 5 6) (1) (0))
;          ((1 2 3 4 5 6) (0))
;          ((0 1 2 3 4 5 6)))
;        '(4 2 1) '(2 0 0) 7)
; '((1 3 4 5 N) (N 2 N N N N) (0 N N N N N N)))
;(check-expect
; (cycle '((5 N N 2) (N N N N 4 5))
;        '(((0 1 2 3) (4 5))
;          ((0 1 2 3 4 5)))
;        '(2 2) '(2 0) 6)
; '((N 2 3 N) (N N N N 4 5)))
;(check-expect
; (cycle '((N 1 2)) '(((0 1 2))) '(2) '(0) 3) 'impossible)

;; cycle: Guess History (listof Nat) (listof Nat) Nat -> Guess
;; Requires:
;;    guess is the same length as the first of history
;;    guess is numerically correct with respect to history, r, and w
(define (cycle guess history r w code-length)
  ;; Step 1: Stretch whites.
  (if (empty? guess)
      'impossible
      (local [(define stretched-mouth
                (reverse
                 (let loop ([rev-guess-mouth (reverse (first guess))]
                            [rev-current-mouth
                             (reverse (first (first history)))])
                   (cond [(empty? rev-guess-mouth)
                          (list 'do-next-step)]
                         [else
                          (local [(define guess-index
                                    (first rev-guess-mouth))
                                  (define index
                                    (first rev-current-mouth))]

                            (cond
                              [(or (symbol? guess-index)
                                   (red? guess-index index))
                               (cons guess-index
                                     (loop (rest rev-guess-mouth)
                                           (rest rev-current-mouth)))]
                              [(= (add-mod 1 guess-index code-length)
                                  index)
                               (cons (add-mod 1 index code-length)
                                     (loop (rest rev-guess-mouth)
                                           (rest rev-current-mouth)))]
                              [else
                               (cons (add-mod 1 guess-index
                                              code-length)
                                     (rest rev-guess-mouth))]))]))))]

        (cond
          [(= (length stretched-mouth)
              (length (first guess)))
           (cons stretched-mouth (rest guess))]
          [else
           ;; Step 2: Move whites.
           (local [(define index-and-count
                     (let loop ([this-index
                                 (sub1
                                  (length (rest stretched-mouth)))]
                                [temp-count 0]
                                [rev-guess-mouth
                                 (reverse (rest stretched-mouth))]
                                [rev-current-mouth
                                 (reverse (first (first history)))]
                                [found-void-symbol? false])
                       (cond [(empty? rev-guess-mouth)
                              (list -1 temp-count)]
                             [else
                              (local [(define guess-index
                                        (first rev-guess-mouth))
                                      (define index
                                        (first rev-current-mouth))]

                                (cond
                                  [found-void-symbol?
                                   (cond [(white? guess-index index)
                                          (list this-index
                                                (add1 temp-count))]
                                         [else
                                          (loop
                                           (sub1 this-index)
                                           temp-count
                                           (rest rev-guess-mouth)
                                           (rest rev-current-mouth)
                                           true)])]
                                  [(white? guess-index index)
                                   (loop (sub1 this-index)
                                         (add1 temp-count)
                                         (rest rev-guess-mouth)
                                         (rest rev-current-mouth)
                                         false)]
                                  [(symbol? guess-index)
                                   (loop (sub1 this-index)
                                         temp-count
                                         (rest rev-guess-mouth)
                                         (rest rev-current-mouth)
                                         true)]
                                  [else
                                   (loop (sub1 this-index)
                                         temp-count
                                         (rest rev-guess-mouth)
                                         (rest rev-current-mouth)
                                         false)]))])))

                   (define index-movable-w (first index-and-count))
                   (define count-later-w (second index-and-count))]

             (cond
               [(>= index-movable-w 0)
                (local [(define w-moved-mouth
                          (let loop
                            ([steps-until-move index-movable-w]
                             [whites-to-make count-later-w]
                             [guess-mouth (rest stretched-mouth)]
                             [current-mouth
                              (first (first history))])
                            (cond [(> steps-until-move 0)
                                   (cons (first guess-mouth)
                                         (loop (sub1 steps-until-move)
                                               whites-to-make
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                  [(zero? steps-until-move)
                                   (cons void-symbol
                                         (loop -1
                                               whites-to-make
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                  [(empty? guess-mouth) empty]
                                  [(red? (first guess-mouth)
                                         (first current-mouth))
                                   (cons (first guess-mouth)
                                         (loop -1
                                               whites-to-make
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                  [(> whites-to-make 0)
                                   (cons (add-mod
                                          1 (first current-mouth)
                                          code-length)
                                         (loop -1
                                               (sub1 whites-to-make)
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                  [else
                                   (cons void-symbol
                                         (loop -1
                                               0
                                               (rest guess-mouth)
                                               (rest
                                                current-mouth)))])))]

                  (cons w-moved-mouth (rest guess)))]
               [else
                ;; Step 3: Move reds.
                (local [(define w-removed-mouth
                          (map (lambda (guess-index index)
                                 (cond [(red? guess-index index)
                                        guess-index]
                                       [else void-symbol]))
                               (rest stretched-mouth)
                               (first (first history))))

                        (define count-w
                          (- (length (filter symbol? w-removed-mouth))
                             (length
                              (filter symbol?
                                      (rest stretched-mouth)))))

                        (define index-movable-r
                          (let loop ([this-index 0]
                                     [temp-index -1]
                                     [mouth w-removed-mouth])
                            (cond [(empty? mouth) temp-index]
                                  [(and (number? (first mouth))
                                        (member? void-symbol mouth))
                                   (loop (add1 this-index)
                                         this-index
                                         (rest mouth))]
                                  [else (loop (add1 this-index)
                                              temp-index
                                              (rest mouth))])))]

                  (cond
                    [(>= index-movable-r 0)
                     (local [(define r-moved-mouth
                               (let loop
                                 ([steps-until-move
                                   index-movable-r]
                                  [reds-to-make 'to-be-determined]
                                  [guess-mouth w-removed-mouth]
                                  [current-mouth
                                   (first (first history))])
                                 (cond [(> steps-until-move 0)
                                        (cons (first guess-mouth)
                                              (loop
                                               (sub1 steps-until-move)
                                               reds-to-make
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                       [(zero? steps-until-move)
                                        (cons void-symbol
                                              (loop
                                               -1
                                               (length
                                                (filter number?
                                                        guess-mouth))
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                       [(> reds-to-make 0)
                                        (cons (first current-mouth)
                                              (loop
                                               -1
                                               (sub1 reds-to-make)
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                       [else
                                        (map (lambda (x) void-symbol)
                                             guess-mouth)])))]

                       (fill-w count-w
                               (cons r-moved-mouth (rest guess))
                               (first history)
                               code-length))]
                    [else
                     ;; Step 4: Step back one level.
                     (generate (complete (rectify (cycle
                                                   (rest guess)
                                                   (rest history)
                                                   (rest r)
                                                   (rest w)
                                                   code-length)
                                                  (rest history)
                                                  (rest r)
                                                  (rest w)
                                                  code-length)
                                         code-length)
                               history r w code-length)]))]))]))))


;; ---------------
;; (simplify guess) removes the extraneous void symbols from guess.
;; Examples:
;(check-expect (simplify '((2 3) (1 N N) (0 N N N))) '((2 3) (1) (0)))
;(check-expect (simplify '((0 1 2))) '((0 1 2)))

;; simplify: Guess -> Attempt
(define (simplify guess)
  (map (lambda (inner-mouth)
         (filter number? inner-mouth))
       guess))


;; ---------------
;; (red? guess-index index) produces true iff guess-index
;;    is a number equal to index.
;; Examples:
;(check-expect (red? 1 1) true)
;(check-expect (red? 0 1) false)
;(check-expect (red? 'N 1) false)

;; red?: GuessIndex Index -> Bool
(define (red? guess-index index)
  (and (number? guess-index)
       (= guess-index index)))


;; ---------------
;; (white? guess-index index) produces true iff guess-index
;;    is a number different from index.
;; Examples:
;(check-expect (white? 1 1) false)
;(check-expect (white? 0 1) true)
;(check-expect (white? 'N 1) false)

;; white?: GuessIndex Index -> Bool
(define (white? guess-index index)
  (and (number? guess-index)
       (not (= guess-index index))))


;; ---------------
;; (fill nr nw attempt code-length) changes the positions in the first
;;    of guess to an initial nr red marks and nw white marks, for a
;;    code of length code-length.
;; Examples:
;(check-expect (fill 0 0 '((1 2 3) (0 N N N)) 4) '((N N N) (0 N N N)))
;(check-expect (fill 2 0 '((1 2 3) (0 N N N)) 4) '((1 2 N) (0 N N N)))
;(check-expect (fill 0 2 '((1 2 3) (0 N N N)) 4) '((2 3 N) (0 N N N)))
;(check-expect (fill 1 1 '((1 2 3) (0 N N N)) 4) '((1 3 N) (0 N N N)))
;(check-expect (fill 1 2 '((1 2 3) (0 N N N)) 4) '((1 3 0) (0 N N N)))

;; fill: Nat Nat Attempt Nat -> Guess
;; Requires: nr + nw <= (length (first attempt))
(define (fill nr nw attempt code-length)
  (fill-w nw (fill-r nr attempt) attempt code-length))


;; ---------------
;; (fill-r nr guess) changes the positions in the first of guess to
;;    an initial nr red marks and no white marks.
;; Examples:
;(check-expect (fill-r 0 '((1 2 3) (0 N N N))) '((N N N) (0 N N N)))
;(check-expect (fill-r 1 '((1 2 3) (0 N N N))) '((1 N N) (0 N N N)))
;(check-expect (fill-r 2 '((1 2 3) (0 N N N))) '((1 2 N) (0 N N N)))
;(check-expect (fill-r 3 '((1 2 3) (0 N N N))) '((1 2 3) (0 N N N)))

;; fill-r: Nat Guess -> Guess
;; Requires:
;;    the first of guess contains only numbers
;;    nr <= (length guess)
(define (fill-r nr guess)
  (cons (let fill-r/mouth ([mouth (first guess)] [nr nr])
          (cond [(zero? nr)
                 (map (lambda (x) void-symbol) mouth)]
                [else (cons (first mouth)
                            (fill-r/mouth (rest mouth)
                                          (sub1 nr)))]))
        (rest guess)))


;; ---------------
;; (fill-w nw guess current code-length) changes the void symbols
;;    in the first of guess to an initial nw white marks with respect
;;    to the first of current, for a code of length code-length.
;; Examples:
;(check-expect (fill-w 0 '((N N N) (0 N N N)) '((1 2 3) (0)) 4)
;              '((N N N) (0 N N N)))
;(check-expect (fill-w 2 '((N N N) (0 N N N)) '((1 2 3) (0)) 4)
;              '((2 3 N) (0 N N N)))
;(check-expect (fill-w 1 '((1 N N) (0 N N N)) '((1 2 3) (0)) 4)
;              '((1 3 N) (0 N N N)))
;(check-expect (fill-w 2 '((1 N N) (0 N N N)) '((1 2 3) (0)) 4)
;              '((1 3 0) (0 N N N)))
;(check-expect (fill-w 0 '((1 2 N) (0 N N N)) '((1 2 3) (0)) 4)
;              '((1 2 N) (0 N N N)))

;; fill-w: Nat Guess Attempt Nat -> Guess
(define (fill-w nw guess current code-length)
  (cons (let fill-w/mouth ([guess-mouth (first guess)]
                           [current-mouth (first current)]
                           [nw nw])
          (cond [(empty? guess-mouth) empty]
                [(number? (first guess-mouth))
                 (cons (first guess-mouth)
                       (fill-w/mouth (rest guess-mouth)
                                     (rest current-mouth)
                                     nw))]
                [(zero? nw)
                 (cons void-symbol
                       (fill-w/mouth (rest guess-mouth)
                                     (rest current-mouth)
                                     nw))]
                [else
                 (cons (add-mod 1 (first current-mouth)
                                code-length)
                       (fill-w/mouth (rest guess-mouth)
                                     (rest current-mouth)
                                     (sub1 nw)))]))
        (rest guess)))


;; ---------------
;; (count red? guess current) produces the number of reds in guess
;;    with respect to current if red? is true, or of whites otherwise.
;; Examples:
;(check-expect (count true  '((N 1 N N)) '((0 1 2 3))) 1)
;(check-expect (count false '((N 1 N N)) '((0 1 2 3))) 0)
;(check-expect (count true  '((N 2 N) (N 1 N N)) '((1 2 3) (0))) 1)
;(check-expect (count false '((N 2 N) (N 1 N N)) '((1 2 3) (0))) 1)
;(check-expect
; (count true
;        '(() (1 2 0) (N N N 3) (N N N N) (N N N N) (N N N N))
;        '(() (0 2 3) (1) () () ()))
; 2)
;(check-expect
; (count false
;        '(() (1 2 0) (N N N 3) (N N N N) (N N N N) (N N N N))
;        '(() (0 2 3) (1) () () ()))
; 2)

;; count: Bool Guess Attempt -> Nat
;; Requires: guess and current are the same length
(define (count red? guess current)
  (foldl + 0
         (map (lambda (guess-mouth current-mouth)
                (length (filter (lambda (guess-index)
                                  (if (member? guess-index
                                               current-mouth)
                                      red?
                                      (not red?)))
                                guess-mouth)))
              (simplify guess)
              current)))


;; ---------------
;; (add-mod a b n) produces the sum of a and b, modulo n.
;; Examples:
;(check-expect (add-mod 1 2 4) 3)
;(check-expect (add-mod 1 2 3) 0)
;(check-expect (add-mod 0 2 3) 2)
;(check-expect (add-mod 2 2 3) 1)

;; add-mod: Nat Nat Nat -> Nat
;; Requires:
;;    0 <= a < n
;;    0 <= b < n
(define (add-mod a b n)
  (modulo (+ a b) n))
