;; -------------------------------------------------------------------
;;    Joseph Vendryes
;;    May 2021
;;    Mastermind v2 Model
;; -------------------------------------------------------------------

#lang racket

(require test-engine/racket-tests)

;; the module plays a game of Mastermind, in the "mind" role

(provide
 (prefix-out
  mastermind-
  (combine-out

   ;; Nat Nat -> Board
   ;; make the first play, given code length and pool size
   first-play

   ;; Board Nat Nat -> Board
   ;; make another play, given the play history and new marks
   play

   ;; Board -> Bool
   ;; check if the previous play concluded with no solution
   impossible?

   ;; Board -> (listof Nat)
   ;; retrieve the latest (unmarked) guess on the board
   current-guess

   ;; Board -> (listof (listof Nat))
   ;; retrieve a list of past guesses from the board, latest first
   guess-history

   ;; Board -> (listof Nat)
   ;; retrieve a list of past R marks from the board, latest first
   r-history

   ;; Board -> (listof Nat)
   ;; retrieve a list of past W marks from the board, latest first
   w-history)))


;; -------------------------------------------------------------------
;; Algorithm Discussion and Terminology

;; In this discussion, a basic familiarity with the game of Mastermind
;;    is assumed.
;; The algorithm implemented here performs the role of the mind,
;;    which entails generating guesses based on previous attempts and
;;    their associated marks. For ease of computation, the colours of
;;    which the code is comprised are represented by natural numbers.
;;    Marks are supplied in aggregate per attempt, where R marks
;;    represent the right colour in the Right spot, and W marks
;;    represent the right colour in the Wrong spot. Past attempts are
;;    stored in a list, ordered with the most recent attempt at the
;;    front of the list. Marks are stored similarly, with separate
;;    lists for R and W marks.
;; Past attempts are stored in a different format from how they would
;;    typically be displayed. Considering the typical display format
;;    as an indexed list, this storage format specifies a list of
;;    indices for each colour. These lists of indices are placed into
;;    a larger list, which represents a single attempt. The last list
;;    in an attempt contains the indices at which that attempt assigns
;;    the colour 0, the second last contains the indices for 1, and so
;;    increasing to the front of the list. Not every attempt uses
;;    every colour, but the number of colours used can be found by
;;    counting the number of lists in a given attempt.
;; A new guess is generated by tentatively assigning the aggregate
;;    marks for each past attempt to specific items in that attempt.
;;    Once a consistent arrangement is found, it immediately implies
;;    a certain number of items in the new guess. The remaining spots
;;    in the new guess are filled with the smallest colour (number)
;;    that does not create a discrepancy with the specifically
;;    assigned marks.
;; When assigning marks specifically, the arrangement cycles through
;;    a pattern until consistency is reached. In this pattern,
;;    priority is given to the smaller colours to remain the same
;;    while all possible combinations of the larger colours are tried.
;;    The arrangement itself is passed on from attempt to attempt
;;    under the moniker of "guess," and it closely resembles an
;;    attempt. The real difference between the guess and an attempt is
;;    that the guess retains "void symbols" from previous assignments.
;;    Void symbols are place markers for the indices assigned as not
;;    having merited either an R or W mark. They take the form of
;;    the value 'N. When a consistent arrangement is found, the void
;;    symbols are filtered out of the guess, a new list of all missing
;;    indices is added to the front of the guess, and this is added
;;    onto the front of the list of past attempts.
;; Since the largest colours are cycled first, and since they are
;;    always the most recent and so appear at the front of the guess,
;;    enough calculation is performed on the first list in the guess
;;    to warrant its own name: the "mouth" of the guess. Similarly,
;;    each attempt has a mouth, against which the guess mouth can be
;;    compared to distinguish R and W assignments. This
;;    comparison is crucial to the cycling process, which proceeds as
;;    follows:
;;       1. Stretch Ws
;;             A W in the guess mouth (a number different from
;;             its correspondent in the current attempt mouth)
;;             is "stretchable" if it can be "stretched" once without
;;             becoming an R (the same as its correspondent). To
;;             stretch a W, add 1 to it. If this results in an
;;             index beyond the code length, replace it with 0.
;;          In this step, stretch the last stretchable W in the
;;             guess mouth, and do the following to all later Ws:
;;                1. Set equal to correspondent,
;;                2. Stretch once. The W is now called "fresh."
;;             Only if there is no stretchable W, move to step 2.
;;       2. Move Ws
;;             To "move" a W or R to a void symbol, simply set
;;             the W or R as a void symbol and the void symbol
;;             as a fresh W or an R. A W or R is "movable"
;;             if a void symbol occurs after it in the guess mouth.
;;          In this step, move the last movable W to the next
;;             void symbol. Move each later W as far to the front
;;             as possible without changing the order of the Ws.
;;             Only if there is no movable W, move to step 3.
;;       3. Move Rs
;;          In this step, first count the number of Ws and set
;;             them all as void symbols. Then move the last movable
;;             R to the next void symbol, and move each later R
;;             as far to the front as possible without changing the
;;             order of the Rs. Finally, recalling the number of
;;             Ws, set the first that many void symbols as fresh
;;             Ws.
;;             Only if there is no movable R, move to step 4.
;;       4. Step back one level
;;          In this step, the guess mouth cannot be cycled. Go to the
;;             previous attempt by taking the rest of the guess and
;;             the rest of the history of attempts, and cycle that
;;             until it is consistent. Then return to this attempt and
;;             cycle until it is consistent.
;; The first guess is always comprised only of the smallest colour, 0,
;;    since there are no previous marks. Each successive guess adds
;;    another colour, until the sum of R and W marks is equal
;;    to the length of the code. At that point, the colours in the
;;    master code are known, and they are simply rearranged until the
;;    correct arrangement is discovered.


;; -------------------------------------------------------------------
;; Data Definitions

;; These data definitions utilize the parameters code-length and
;;    pool-size, which specify the length of the code and the number
;;    of colours, respectively. Also void-symbol, which is a Sym.

;; A Colour is a Nat < pool-size

;; An Index is a Nat < code-length

;; An Attempt is a non-empty (listof (listof Index))
;;    containing every possible Index exactly once.

;; A History is a non-empty (listof Attempt)
;; requires:
;;    the last Attempt has length 1
;;    each Attempt has length 1 more than the next

;; An AttemptMouth is a (listof Index)

;; A GuessIndex is (Anyof Index void-symbol)

;; A Guess is one of
;; * a non-empty (listof (listof GuessIndex))
;; * 'impossible

;; A GuessMouth is a (listof GuessIndex)

(define-struct board
  (guess history rs ws code-length pool-size))
;; A Board is a
;;    (make-board Guess History (listof Index) (listof Index) Nat Nat)
;; requires: history, rs, and ws are all the same length


;; -------------------------------------------------------------------
;; Constants

(define void-symbol 'N)


;; -------------------------------------------------------------------
;; Implementation

(define (first-play code-length pool-size)
  (define guess (list (build-list code-length identity)))
  (define history empty)
  (define rs empty)
  (define ws empty)
  
  (make-board guess history rs ws code-length pool-size))


(define (play board new-r new-w)
  (define guess       (board-guess       board))
  (define history     (board-history     board))
  (define rs          (board-rs          board))
  (define ws          (board-ws          board))
  (define code-length (board-code-length board))
  (define pool-size   (board-pool-size   board))

  (define new-history (cons (simplify guess) history))
  (define new-rs      (cons new-r rs))
  (define new-ws      (cons new-w ws))
  (define new-guess   (complete (generate guess new-history
                                          new-rs new-ws code-length)
                                code-length))

  (make-board new-guess new-history new-rs new-ws
              code-length pool-size))


(define (impossible? board)
  (or (and (symbol? (board-guess board))
           (symbol=? (board-guess board) 'impossible))
      (colours-exhausted? board)))


(define (current-guess board)
  (attempt->list (simplify (board-guess board))))


(define (guess-history board)
  (map attempt->list (board-history board)))


(define (r-history board)
  (board-rs board))


(define (w-history board)
  (board-ws board))


;; Board -> Bool
;; determine whether the current guess on the board uses colours
;;    that are not available
(define (colours-exhausted? board)
  (and (> (length (board-guess board))
          (board-pool-size board))
       (not (empty? (first (board-guess board))))))


;; Guess History (listof Nat) (listof Nat) Nat -> Guess
;; requires:
;;    guess is the same length as the first of history
;;      or guess is 'impossible
;;    rs and ws are the same length as history
;; produce a consistent arrangement distributing rs and ws through
;;    history, cycling from a numerical correction of guess
(define (generate guess history rs ws code-length)
  (cond [(and (symbol? guess) (symbol=? guess 'impossible))
         'impossible]
        [else
         (define current (first history))

         (define count-r (count true (rest guess) (rest current)))
         (define count-w (count false (rest guess) (rest current)))

         (define excess-r (- (first rs) count-r))
         (define excess-w (- (first ws) count-w))

         (if (and (>= excess-r 0)
                  (>= excess-w 0))
             (rectify (fill excess-r
                            excess-w
                            (cons (first current) (rest guess))
                            code-length)
                      history rs ws code-length)
             (generate (complete (rectify (cycle (rest guess)
                                                 (rest history)
                                                 (rest rs)
                                                 (rest ws)
                                                 code-length)
                                          (rest history)
                                          (rest rs)
                                          (rest ws)
                                          code-length)
                                 code-length)
                       history rs ws code-length))]))


;; Guess Nat -> Guess
;; add onto the front of guess a list of all indices less than
;;    code-length that are not already in guess
(define (complete rguess code-length)
  (if (and (symbol? rguess) (symbol=? rguess 'impossible))
      'impossible
      (cons (filter (lambda (n)
                      (not (member? n (foldr append '() rguess))))
                    (build-list code-length identity))
            rguess)))


;; Any (listof Any) -> Bool
;; determine whether lst contains item
(define (member? item lst)
  (ormap (lambda (lst-item) (equal? item lst-item)) lst))


;; Guess History (listof Nat) (listof Nat) Nat -> Guess
;; requires:
;;    guess is the same length as the first of history
;;      or guess is 'impossible
;;    rs and ws are the same length as history
;; produces guess if it is consistent, or else cycle it with respect
;;    to history, rs, and ws, until it is consistent
(define (rectify guess history rs ws code-length)
  (cond [(and (symbol? guess) (symbol=? guess 'impossible))
         'impossible]
        [(rectified? guess (first history) (first rs) (first ws))
         guess]
        [else (rectify (cycle guess history rs ws code-length)
                       history rs ws code-length)]))


;; Guess Attempt Nat Nat -> Bool
;; requires: guess and current are the same non-zero length
;; determine whether guess is a consistent correction of current
;;    with count-r R marks and count-w W marks
(define (rectified? guess current count-r count-w)
  (and (let no-double-numbers ([lst (foldr append '() guess)])
         (or (empty? lst)
             (and (no-double-numbers (rest lst))
                  (not (and (number? (first lst))
                            (member? (first lst) (rest lst)))))))
       (= count-r (count true guess current))
       (= count-w (count false guess current))))


;; Guess History (listof Nat) (listof Nat) Nat -> Guess
;; requires:
;;    guess is the same length as the first of history
;;    guess is numerically correct with respect to history, rs, and ws
;; cycle guess with respect to history, rs, and ws
(define (cycle guess history rs ws code-length)
  ;; Step 1: Stretch Ws.
  (if (empty? guess)
      'impossible
      (local [(define stretched-mouth
                (reverse
                 (let loop ([rev-guess-mouth (reverse (first guess))]
                            [rev-current-mouth
                             (reverse (first (first history)))])
                   (cond [(empty? rev-guess-mouth)
                          (list 'do-next-step)]
                         [else
                          (local [(define guess-index
                                    (first rev-guess-mouth))
                                  (define index
                                    (first rev-current-mouth))]

                            (cond
                              [(or (symbol? guess-index)
                                   (r? guess-index index))
                               (cons guess-index
                                     (loop (rest rev-guess-mouth)
                                           (rest rev-current-mouth)))]
                              [(= (add-mod 1 guess-index code-length)
                                  index)
                               (cons (add-mod 1 index code-length)
                                     (loop (rest rev-guess-mouth)
                                           (rest rev-current-mouth)))]
                              [else
                               (cons (add-mod 1 guess-index
                                              code-length)
                                     (rest rev-guess-mouth))]))]))))]

        (cond
          [(= (length stretched-mouth)
              (length (first guess)))
           (cons stretched-mouth (rest guess))]
          [else
           ;; Step 2: Move Ws.
           (local [(define index-and-count
                     (let loop ([this-index
                                 (sub1
                                  (length (rest stretched-mouth)))]
                                [temp-count 0]
                                [rev-guess-mouth
                                 (reverse (rest stretched-mouth))]
                                [rev-current-mouth
                                 (reverse (first (first history)))]
                                [found-void-symbol? false])
                       (cond [(empty? rev-guess-mouth)
                              (list -1 temp-count)]
                             [else
                              (local [(define guess-index
                                        (first rev-guess-mouth))
                                      (define index
                                        (first rev-current-mouth))]

                                (cond
                                  [found-void-symbol?
                                   (cond [(w? guess-index index)
                                          (list this-index
                                                (add1 temp-count))]
                                         [else
                                          (loop
                                           (sub1 this-index)
                                           temp-count
                                           (rest rev-guess-mouth)
                                           (rest rev-current-mouth)
                                           true)])]
                                  [(w? guess-index index)
                                   (loop (sub1 this-index)
                                         (add1 temp-count)
                                         (rest rev-guess-mouth)
                                         (rest rev-current-mouth)
                                         false)]
                                  [(symbol? guess-index)
                                   (loop (sub1 this-index)
                                         temp-count
                                         (rest rev-guess-mouth)
                                         (rest rev-current-mouth)
                                         true)]
                                  [else
                                   (loop (sub1 this-index)
                                         temp-count
                                         (rest rev-guess-mouth)
                                         (rest rev-current-mouth)
                                         false)]))])))

                   (define index-movable-w (first index-and-count))
                   (define count-later-w (second index-and-count))]

             (cond
               [(>= index-movable-w 0)
                (local [(define w-moved-mouth
                          (let loop
                            ([steps-until-move index-movable-w]
                             [ws-to-make count-later-w]
                             [guess-mouth (rest stretched-mouth)]
                             [current-mouth
                              (first (first history))])
                            (cond [(> steps-until-move 0)
                                   (cons (first guess-mouth)
                                         (loop (sub1 steps-until-move)
                                               ws-to-make
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                  [(zero? steps-until-move)
                                   (cons void-symbol
                                         (loop -1
                                               ws-to-make
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                  [(empty? guess-mouth) empty]
                                  [(r? (first guess-mouth)
                                         (first current-mouth))
                                   (cons (first guess-mouth)
                                         (loop -1
                                               ws-to-make
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                  [(> ws-to-make 0)
                                   (cons (add-mod
                                          1 (first current-mouth)
                                          code-length)
                                         (loop -1
                                               (sub1 ws-to-make)
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                  [else
                                   (cons void-symbol
                                         (loop -1
                                               0
                                               (rest guess-mouth)
                                               (rest
                                                current-mouth)))])))]

                  (cons w-moved-mouth (rest guess)))]
               [else
                ;; Step 3: Move Rs.
                (local [(define w-removed-mouth
                          (map (lambda (guess-index index)
                                 (cond [(r? guess-index index)
                                        guess-index]
                                       [else void-symbol]))
                               (rest stretched-mouth)
                               (first (first history))))

                        (define count-w
                          (- (length (filter symbol? w-removed-mouth))
                             (length
                              (filter symbol?
                                      (rest stretched-mouth)))))

                        (define index-movable-r
                          (let loop ([this-index 0]
                                     [temp-index -1]
                                     [mouth w-removed-mouth])
                            (cond [(empty? mouth) temp-index]
                                  [(and (number? (first mouth))
                                        (member? void-symbol mouth))
                                   (loop (add1 this-index)
                                         this-index
                                         (rest mouth))]
                                  [else (loop (add1 this-index)
                                              temp-index
                                              (rest mouth))])))]

                  (cond
                    [(>= index-movable-r 0)
                     (local [(define r-moved-mouth
                               (let loop
                                 ([steps-until-move
                                   index-movable-r]
                                  [rs-to-make 'to-be-determined]
                                  [guess-mouth w-removed-mouth]
                                  [current-mouth
                                   (first (first history))])
                                 (cond [(> steps-until-move 0)
                                        (cons (first guess-mouth)
                                              (loop
                                               (sub1 steps-until-move)
                                               rs-to-make
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                       [(zero? steps-until-move)
                                        (cons void-symbol
                                              (loop
                                               -1
                                               (length
                                                (filter number?
                                                        guess-mouth))
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                       [(> rs-to-make 0)
                                        (cons (first current-mouth)
                                              (loop
                                               -1
                                               (sub1 rs-to-make)
                                               (rest guess-mouth)
                                               (rest current-mouth)))]
                                       [else
                                        (map (lambda (x) void-symbol)
                                             guess-mouth)])))]

                       (fill-w count-w
                               (cons r-moved-mouth (rest guess))
                               (first history)
                               code-length))]
                    [else
                     ;; Step 4: Step back one level.
                     (generate (complete (rectify (cycle
                                                   (rest guess)
                                                   (rest history)
                                                   (rest rs)
                                                   (rest ws)
                                                   code-length)
                                                  (rest history)
                                                  (rest rs)
                                                  (rest ws)
                                                  code-length)
                                         code-length)
                               history rs ws code-length)]))]))]))))


;; Guess -> Attempt
;; remove the extraneous void symbols from guess
(define (simplify guess)
  (map (lambda (inner-mouth)
         (filter number? inner-mouth))
       guess))


;; GuessIndex Index -> Bool
;; determine whether guess-index is a number equal to index
(define (r? guess-index index)
  (and (number? guess-index)
       (= guess-index index)))


;; GuessIndex Index -> Bool
;; determine whether guess-index is a number different from index
(define (w? guess-index index)
  (and (number? guess-index)
       (not (= guess-index index))))


;; Nat Nat Attempt Nat -> Guess
;; requires: nr + nw <= (length (first attempt))
;; change the positions in the first of guess to an initial nr R marks
;;    and nw W marks
(define (fill nr nw attempt code-length)
  (fill-w nw (fill-r nr attempt) attempt code-length))


;; Nat Guess -> Guess
;; requires:
;;    the first of guess contains only numbers
;;    nr <= (length guess)
;; change the positions in the first of guess to an initial nr R marks
;;    and no W marks
(define (fill-r nr guess)
  (cons (let fill-r/mouth ([mouth (first guess)] [nr nr])
          (cond [(zero? nr)
                 (map (lambda (x) void-symbol) mouth)]
                [else (cons (first mouth)
                            (fill-r/mouth (rest mouth)
                                          (sub1 nr)))]))
        (rest guess)))


;; Nat Guess Attempt Nat -> Guess
;; change the void symbols in the first of guess to an initial nw
;;    W marks with respect to the first of current
(define (fill-w nw guess current code-length)
  (cons (let fill-w/mouth ([guess-mouth (first guess)]
                           [current-mouth (first current)]
                           [nw nw])
          (cond [(empty? guess-mouth) empty]
                [(number? (first guess-mouth))
                 (cons (first guess-mouth)
                       (fill-w/mouth (rest guess-mouth)
                                     (rest current-mouth)
                                     nw))]
                [(zero? nw)
                 (cons void-symbol
                       (fill-w/mouth (rest guess-mouth)
                                     (rest current-mouth)
                                     nw))]
                [else
                 (cons (add-mod 1 (first current-mouth)
                                code-length)
                       (fill-w/mouth (rest guess-mouth)
                                     (rest current-mouth)
                                     (sub1 nw)))]))
        (rest guess)))


;; Bool Guess Attempt -> Nat
;; requires: guess and current are the same length
;; count the number of Rs in guess with respect to current if r? is
;;    true, or of Ws otherwise
(define (count r? guess current)
  (foldl + 0
         (map (lambda (guess-mouth current-mouth)
                (length (filter (lambda (guess-index)
                                  (if (member? guess-index
                                               current-mouth)
                                      r?
                                      (not r?)))
                                guess-mouth)))
              (simplify guess)
              current)))


;; Nat Nat Nat -> Nat
;; requires:
;;    0 <= a < n
;;    0 <= b < n
;; calculate a + b mod n
(define (add-mod a b n)
  (modulo (+ a b) n))


;; Attempt -> (listof Colour)
;; produce the list of Colours represented by attempt
(define (attempt->list attempt)
  (define (value-label val lst)
    (map (lambda (item) (list item val)) lst))
  (define labelled (map value-label
                        (reverse
                         (build-list (length attempt) (lambda (n) n)))
                        attempt))
  (define merged (foldl append empty labelled))
  (define sorted (sort merged (lambda (item1 item2)
                                (< (first item1) (first item2)))))
  (define vals (map second sorted))

  vals)


;; -------------------------------------------------------------------
;; Tests

;; generate
(check-expect (generate '((0)) '(((0))) '(0) '(0) 1) '((N)))
(check-expect (generate '((0) (N)) '(((0) ()) ((0))) '(0 0) '(0 0) 1)
              '((N) (N)))
(check-expect (generate '((0 1 2)) '(((0 1 2))) '(2) '(0) 3)
              '((0 1 N)))
(check-expect
 (generate '((1 2) (0 N N)) '(((1 2) (0)) ((0 1 2))) '(1 1) '(1 0) 3)
 '((N 2) (N 1 N)))
(check-expect
 (generate '((1 2) (0 N N)) '(((1 2) (0)) ((0 1 2))) '(0 1) '(1 0) 3)
 '((N N) (N 1 N)))

;; complete
(check-expect (complete '((0 N N N)) 4) '((1 2 3) (0 N N N)))
(check-expect (complete '((N 2 N) (N 1 N N)) 4)
              '((0 3) (N 2 N) (N 1 N N)))

;; rectify
(check-expect (rectify '((N)) '(((0))) '(0) '(0) 1) '((N)))
(check-expect (rectify '((N) (N)) '(((0) ()) ((0))) '(0 0) '(0 0) 1)
              '((N) (N)))
(check-expect (rectify '((0 1 N)) '(((0 1 2))) '(2) '(0) 3)
              '((0 1 N)))
(check-expect
 (rectify '((2 N) (0 N N)) '(((1 2) (0)) ((0 1 2))) '(1 1) '(1 0) 3)
 '((N 2) (N 1 N)))

;; rectified?
(check-expect (rectified? '((N 2 N) (N 1 N N)) '((1 2 3) (0)) 1 1)
              true)
(check-expect (rectified? '((2 N N) (0 N N N)) '((1 2 3) (0)) 1 1)
              false)
(check-expect (rectified? '((0 N N) (0 N N N)) '((1 2 3) (0)) 1 1)
              false)

;; cycle
(check-expect
 (cycle '((2 3 5 6 N) (1 N N N N N) (0 N N N N N N))
        '(((2 3 4 5 6) (1) (0))
          ((1 2 3 4 5 6) (0))
          ((0 1 2 3 4 5 6)))
        '(2 1 1) '(2 0 0) 7)
 '((2 3 5 0 N) (1 N N N N N) (0 N N N N N N)))
(check-expect
 (cycle '((2 3 5 4 N) (1 N N N N N) (0 N N N N N N))
        '(((2 3 4 5 6) (1) (0))
          ((1 2 3 4 5 6) (0))
          ((0 1 2 3 4 5 6)))
        '(2 1 1) '(2 0 0) 7)
 '((2 3 6 6 N) (1 N N N N N) (0 N N N N N N)))
(check-expect
 (cycle '((2 3 3 4 N) (1 N N N N N) (0 N N N N N N))
        '(((2 3 4 5 6) (1) (0))
          ((1 2 3 4 5 6) (0))
          ((0 1 2 3 4 5 6)))
        '(2 1 1) '(2 0 0) 7)
 '((2 3 5 N 0) (1 N N N N N) (0 N N N N N N)))
(check-expect
 (cycle '((2 3 N 4 5) (1 N N N N N) (0 N N N N N N))
        '(((2 3 4 5 6) (1) (0))
          ((1 2 3 4 5 6) (0))
          ((0 1 2 3 4 5 6)))
        '(2 1 1) '(2 0 0) 7)
 '((2 4 4 6 N) (1 N N N N N) (0 N N N N N N)))
(check-expect
 (cycle '((N 2 3 5 6) (1 N N N N N) (0 N N N N N N))
        '(((2 3 4 5 6) (1) (0))
          ((1 2 3 4 5 6) (0))
          ((0 1 2 3 4 5 6)))
        '(4 2 1) '(2 0 0) 7)
 '((1 3 4 5 N) (N 2 N N N N) (0 N N N N N N)))
(check-expect
 (cycle '((5 N N 2) (N N N N 4 5))
        '(((0 1 2 3) (4 5))
          ((0 1 2 3 4 5)))
        '(2 2) '(2 0) 6)
 '((N 2 3 N) (N N N N 4 5)))
(check-expect
 (cycle '((N 1 2)) '(((0 1 2))) '(2) '(0) 3) 'impossible)

;; simplify
(check-expect (simplify '((2 3) (1 N N) (0 N N N))) '((2 3) (1) (0)))
(check-expect (simplify '((0 1 2))) '((0 1 2)))

;; r?
(check-expect (r? 1 1) true)
(check-expect (r? 0 1) false)
(check-expect (r? 'N 1) false)

;; w?
(check-expect (w? 1 1) false)
(check-expect (w? 0 1) true)
(check-expect (w? 'N 1) false)

;; fill
(check-expect (fill 0 0 '((1 2 3) (0 N N N)) 4) '((N N N) (0 N N N)))
(check-expect (fill 2 0 '((1 2 3) (0 N N N)) 4) '((1 2 N) (0 N N N)))
(check-expect (fill 0 2 '((1 2 3) (0 N N N)) 4) '((2 3 N) (0 N N N)))
(check-expect (fill 1 1 '((1 2 3) (0 N N N)) 4) '((1 3 N) (0 N N N)))
(check-expect (fill 1 2 '((1 2 3) (0 N N N)) 4) '((1 3 0) (0 N N N)))

;; fill-r
(check-expect (fill-r 0 '((1 2 3) (0 N N N))) '((N N N) (0 N N N)))
(check-expect (fill-r 1 '((1 2 3) (0 N N N))) '((1 N N) (0 N N N)))
(check-expect (fill-r 2 '((1 2 3) (0 N N N))) '((1 2 N) (0 N N N)))
(check-expect (fill-r 3 '((1 2 3) (0 N N N))) '((1 2 3) (0 N N N)))

;; fill-w
(check-expect (fill-w 0 '((N N N) (0 N N N)) '((1 2 3) (0)) 4)
              '((N N N) (0 N N N)))
(check-expect (fill-w 2 '((N N N) (0 N N N)) '((1 2 3) (0)) 4)
              '((2 3 N) (0 N N N)))
(check-expect (fill-w 1 '((1 N N) (0 N N N)) '((1 2 3) (0)) 4)
              '((1 3 N) (0 N N N)))
(check-expect (fill-w 2 '((1 N N) (0 N N N)) '((1 2 3) (0)) 4)
              '((1 3 0) (0 N N N)))
(check-expect (fill-w 0 '((1 2 N) (0 N N N)) '((1 2 3) (0)) 4)
              '((1 2 N) (0 N N N)))

;; count
(check-expect (count true  '((N 1 N N)) '((0 1 2 3))) 1)
(check-expect (count false '((N 1 N N)) '((0 1 2 3))) 0)
(check-expect (count true  '((N 2 N) (N 1 N N)) '((1 2 3) (0))) 1)
(check-expect (count false '((N 2 N) (N 1 N N)) '((1 2 3) (0))) 1)
(check-expect
 (count true
        '(() (1 2 0) (N N N 3) (N N N N) (N N N N) (N N N N))
        '(() (0 2 3) (1) () () ()))
 2)
(check-expect
 (count false
        '(() (1 2 0) (N N N 3) (N N N N) (N N N N) (N N N N))
        '(() (0 2 3) (1) () () ()))
 2)

;; add-mod
(check-expect (add-mod 1 2 4) 3)
(check-expect (add-mod 1 2 3) 0)
(check-expect (add-mod 0 2 3) 2)
(check-expect (add-mod 2 2 3) 1)

;; attempt->list
(check-expect (attempt->list '()) '())
(check-expect (attempt->list '((0))) '(0))
(check-expect (attempt->list '((1 0 2))) '(0 0 0))
(check-expect (attempt->list '((1) (2 0))) '(0 1 0))
(check-expect (attempt->list '((3 0) (4 1) (2))) '(2 1 0 2 1))

;(test)
